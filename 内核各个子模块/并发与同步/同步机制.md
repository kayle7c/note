# 读写信号量

    

[rw_semaphore 原理与代码分析_rw 任务优先级-CSDN博客](https://blog.csdn.net/feisezaiyue/article/details/127809980)

```c
struct rw_semaphore {
    atomic_long_t count;
    atomic_long_t owner;
#ifdef CONFIG_RWSEM_SPIN_ON_OWNER
    struct optimistic_spin_queue osq; /* spinner MCS lock */
#endif
    raw_spinlock_t wait_lock;
    struct list_head wait_list;
#ifdef CONFIG_DEBUG_RWSEMS
    void *magic;
#endif
#ifdef CONFIG_DEBUG_LOCK_ALLOC
    struct lockdep_map    dep_map;
#endif
};
```

+ count：用于表示该锁的状态，这里是这样排布的：

```c
count bit
 * Bit  0    - writer locked bit
 * Bit  1    - waiters present bit
 * Bit  2    - lock handoff bit
 * Bits 3-7  - reserved
 * Bits 8-62 - 55-bit reader count
 * Bit  63   - read fail bit
```

    第0位是用来标记是否有写者持锁该锁，如果该位位1，此时不允许其他写者或读者获取锁，以保证写操作的独占性。

    第1位是等待者存在位，如果该位为1，表示有进程（写者或读者）正在等待获取该信号量

    8～62位是用来统计读者的数量的

+ owner：持锁的写者或者其中一个读者。这里如何区分owner到底是读锁的持锁者还是写锁的持锁者？结合count的bit0来看。（记得清零第三位才是真实task的）
+ wait_list：等锁者链表：所有等待这把锁的rwsem_waiter插到 sem->wait_list 尾部，然后调用 schedule()睡眠。
  
  ```c
  struct rwsem_waiter {
  	struct list_head list;
      //指向正在等待的 task，唤醒时用它
  	struct task_struct *task;
      //等待类型：
      //RWSEM_WAITING_FOR_WRITE（写者）
      //RWSEM_WAITING_FOR_READ（读者）
  	enum rwsem_waiter_type type;
  	unsigned long timeout;
      //记录“上一次持有读锁的 task 的 owner id”
  	unsigned long last_rowner;
  };
  ```


