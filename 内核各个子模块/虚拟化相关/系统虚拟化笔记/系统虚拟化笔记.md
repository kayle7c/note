# 第三章

## 3.1可虚拟化架构与不可虚拟化架构

    一般来说，虚拟环境由三个部分组成:硬件、VMM 和虚拟机（从架构上来看由下到上分别是硬件、VMM、虚拟机）

       两个概念：敏感指令（操作特权资源的指令）、特权指令（在ring0运行的指令）。所有的特权指令都是敏感指令，然而并不是所有的敏感指令都是特权指令。

       判断一个结构是否可虚拟化，其核心就在于该结构对敏感指令的支持上：如果某些结构上所有敏感指令都是特权指令，则它是可虚拟化的结构;否则，如果它无法支持在所有的敏感指令上触发异常，则不是一个可虚拟化的结构，我们称其存在“虚拟化漏洞”（如果有敏感指令不是特权指令，那么就无法陷入到vmm中，vmm就无法感知到这些敏感指令）

## 3.2 处理器虚拟化

### 3.2.1指令的模拟

    在虚拟化的环境中，原本处于ring0的的操作系统处于ring1，这时候vmm就会接管物理处理器处于ring0，所有操作系统的敏感指令都要经过vmm才能与硬件交互。

    当客户机操作系统访问寄存器时，由于特权级不符合，会抛出异常，由vmm接手，此时vmm会访问为虚拟机设计的虚拟寄存器中：虚拟寄存器往往在内存中。

    在虚拟机切换上下文时，也会保存上下文信息，这些信息就保存在虚拟寄存器中，但是对于虚拟上下文会包括更多的系统寄存器：比如cr0、cr3、cr4、各种MSR等。

    虚拟机的敏感指令是如何陷入VMM的？

    1）基于处理器保护机制触发的异常，例如前面提到的敏感指令的执行。处理器会在执行敏感指令之前，检查其执行条件是否满足，例如当前特权级别、运行模式以及内存映射关系等。一旦任一条件不满足，VMM得到陷入然后进行处理。

    2）虚拟机主动触发异常，也就是通常所说的陷阱。当条件满足时，处理器会在触发陷阱的指令执行完毕后, 再抽出一个异常。虚拟机可以通过陷阱指令来主动请求陷人到VMM中去。例如，在后面介绍的类虚拟化技术就是通过这种方式实现Hypercall 的。

    3）异步中断，包括处理器内部的中断源和外部的设备中断源。这些中断源可以是周期性产生中断的时间源，也可以是根据设备状态产生中断的大多数外设。一旦中断信号到达处理器，处理器会强行中断当前指令，然后跳到VMM注册的中断服务程序，所以这也为VMM的陷入提供了一种途径。例如，VMM可以通过调度算法指定当前虚拟机运行的时间片长度，然后编程外部时钟源，确保时间片用完时触发中断，从而允许VMM进行下一次调度。

### 3.2.2 中断和异常的模拟及注入

     VMM对于异常的虚拟化需要完全遵照物理处理器对于各种异常条件的定义,再根据 庭拟处理器当时的内容，来判断是否需要模拟出 一个虛拟的异常，并注人到虚拟环境中。

    VMM 通常会在硬件异常处理程序和指令模拟代码中进行异常虚拟化的检查。无论是哪一条路径，VMM需要区分两种原因:一是虚拟机自身对运行环境和上下文的设置违背了指令正确执行的条件;二是虚拟机运行在非最高特权级别，由于虚拟化的原因触发的异常。第二种是属于虚拟化方式所造成的。    

    物理中断的触发来自于特定的物理中断源，同样，虛拟中断的触发来自于虚拟设备的模拟程序。当设备模拟器发现虚拟设备状态满足中断产生的条件时，会将这个虚拟中断通知给中断控制器的模拟程序。最后，VMM 会在特定的时候检测虚拟中断控制器的状态，来决定是否模拟一个中断的注入。

### 3.2.3 对称多处理器技术的模拟

    如果虚拟机需要多个处理器，那么就需要模拟多个虚拟处理器，客户SMP中虚拟处理器的数目与实际物理处理器数目之间没有必然联系，也就是说，客户SMP中虚拟处理器的个数可以小于、等于或是大于实际物理处理器个数。   

## 3.3 内存虚拟化

    在没有虚拟化的情况下，操作系统在对内存的使用与管理上己经达成了以下两点认识：1）内存都是从物理地址0开始。2） 内存都是连续的，或者说至少在 一些大的粒度(如256MB) 上连续。

    在虚拟环境中，VMM的任务就是模拟使得虚拟出来的内存仍然符合客户机操作系统对内存的认识。内存虚拟化的核心就是引入一层新的地址空间：客户机物理地址空间。在原本的操作系统中，指令的操作是物理地址，但是在虚拟化中，该物理地址不会被直接送上系统总线交给cpu处理，而是通过VMM将客户机器物理地址转换为真实的物理地址再交给cpu处理。

    对于内存虚拟化，VMM需要做的是：1） 维护客户机物理地址到宿主机物理地址之间的映射关系。  2）截获虛拟机对客户机物理地址的访问，并根据所记录的映射关系，将其转换成宿主机物理地址

    VMM内存虚拟化任务就是跟踪客户页表,当其发生变化时，及时地切入，构造一个有效的客户机虚拟地址到宿主机物理地址间的映射关系，加到物理处理器所遍历的真实页表上。

    对于第二个问题一个最简单的办法就是设法让虛拟机对客户机物理地址空间的每 一次访问都触发异常,然后由VMM来查询地址转换表模拟其访问，但是性能是最差的。

## 3.4 I/O虚拟化

### 3.4.2 设备发现

    设备发现就是要让 VMM 提供一种方式，来让客户机操作系统发现虛拟设备，这样客户机操作系统才能加载相关的驱动程序，这是I/O虚拟化的第一步。设备发现取决于被虚拟的设备类型： 1）模拟一个处于物理总线的设备：a）模拟一个所处总线类型是不可枚举的物理设备，而且该设备本身所属的资源是硬编码固定下来的。这类设备典型的例子就是ISA设备、PS/2键盘、鼠标、RTC及传统IDE控制器等。对于这类设备，驱动程序可能会通过设备特定的方式来检测设备是否存在，例如读取特定端口的状态信息。  b）模拟一个所处总线类型是可枚举的物理设备，而且相关设备资源是软件可配置的。 这类设备典型的例子就是PCI设备。

2）模拟一个完全虚拟的设备....

### 3.4.3 访问截获

    对于不是单独给客户机分配的设备：由于客户机操作系统被降级而运行在一个非特权的环境里，容户机操作系统是否能够访问给定I/O端口就完全由I/O 位图来决定。自然地，VMM 可以把设备的所有端口 I/O 从I/O位图中关闭,这样,当客户指令流在访问该I/0 端口时,物理处理器就会及时地拋出一个保护异常，接着,VMM就可以获得异常原因,然后将请求发送给设备模拟器进行模拟。

    对于是单独给客户机分配的设备：VMM 可以把该设备所属端 又1/0 从1/0 位图中打开,这样，处理器就会把访问发送到系统总线，最终到达目标物理设备而不被模拟。

### 3.4.4 设备虚拟

    在传统的驱动程序流程中，VMM要截获每个寄存器的访问并进行相应的模拟，会导致多次上下文切换。简化后，将驱动分为客户机驱动前端（FE）和VMM驱动后端（BE）。前端将其他模块的请求通过客户机的特殊机制发送给后端，后端处理完请求再给前端通知（相当于将驱动请求整包发给后端，让后端代为处理）

## 3.5 VMM的功能和组成

    VMM分为两部分：虚拟环境的管理和物理资源的管理，物理资源的管理与硬件架构有关

### 3.5.1 虚拟环境的管理

    1.虚拟资源

    通过截获客户机操作系统对处理器、内存和外设等资源的访问，来构建一个虚拟环境。在这个环境中，客户机操作系统认为自己运行在一台计算机上，并唯一地拥有这台“虚拟”机器上的所有资源，需要VMM提供以下模块：1）处理器虚拟化模块 2) 内存虚拟化模块 3） 设备虚拟化模块

    2.虚拟环境的调度

    VMM可以同时构建多个虚拟环境，从而允许多个客户机操作系统并发执行，需要一套策略来调度。VMM的调度程序的调度单位是虚拟处理器，当虚拟处理器被调度到时，VMM调度程序负责将虛拟处理器上下文装载到物理处理器上, 然后虛拟处理器所对应的客户机指令开始真正被执行。当时间片用完或者虚 拟处理器主动让出，调度程序会被触发。调度程序根据调度策略，挑选下一个虚拟处理器继续运行。

    3.虚拟机间通信机制

    VMM 实现虚拟机间的通信机制，并向虚拟机提供相应的API。虛拟机的客户机操作系统通过调用这些API 与其他虚拟机进行通信。这些API 可以是事件通知，也可以是内存共享等。在虚拟机间通信机制 的实现上，严格的安全权限检查也是必需的，否则虛拟机之间的隔离就会受到影响。

    4.虛拟化环境的管理接口

    虚拟机的管理功能由上层的管理程序和VMM提供的管理接口组成。VMM需要提供一组完备的管理接口，来支持虚拟环境的创建、删除、暂停、查询和迁移等功能。

### 3.5.2 物理资源的管理

    1.处理器管理

    包括系统启动时检测并获取所有的处理器;对每个处理器进行初始化, 如设置运行模式、设置页表、设置中断处理函数等;将所有的处理器纳入调度序列，由调度程序对处理器进行调度。

    2.内存管理

    包括系统启动时VMM检测并且获得所有内存;对获得的内存进行初始化，包括分页并设置页表等;提供内存分配的接口，以便VMM的其他模块能够获得/释放内存;给虚拟机分配内存,并且维护虚拟机物理地址与实际物理地址的映射关系,以供 VMM的其他模块查询使用。

    3.中断管理

    VMM负贵初始化并设置中断相关的资源，如处理器中断向量表:Local APIC和中断 控制器(I/O APIC、8259 PIC)。当中断发生后，VMM是接收者，它会根据中断的来源,或者直接处理，或者转发到相关特权虚拟机来处理。

     系统时间、设备管理等....

## 3.6 VMM的分类

### 3.6.1 按虚拟平台分类

    完全虚拟化：用户机察觉不到自己是在虚拟环境中，不对客户机操作系统做任何更改

    以x86架构，完全虚拟化的两个过程：1）软件辅助完全虚拟化：a）优先级压缩：将VMM运行在ring0，客户机操作系统内核在ring1，客户机操作系统用户态在ring3，这样一来，内核触发的特权指令由于特权级不符合，就会触发异常，被VMM捕获。但是x86的设计问题，并不是所有特权指令都能被捕获到。 b）二进制代码翻译：通过扫描并修改客户机的 二进制代码，将难以虛拟化的指令转化为支持虚拟化的指令。VMM通常会对操作系统的二进制代码进行扫描，一旦发现需要处理的指令，就将其翻译成为支持虚拟化的指令块（Cache Block）。这些指令块可以与VMM合作访问受限的虚拟资源，或者显式地触发异常让VMM进一步处理。此外，由于该技术可以修改客户的二进制代码。         2）硬件辅助完全虚拟化：如果硬件本身加人足够的虚拟化功能，就可以截获操作系统对敏感指令 的执行或者对敏感资源的访问，从而通过异常的方式报告给 VMM,这样就解决了虛拟化的问题 

    类虚拟化：VMM虚拟的平台是现实中不存在的，而是经过VMM重新定义的，这样的虚拟平台需要对所运行的客户机操作系统进行或多或少的修改使之适应虚拟环境，因此客户机操作系统知道其运行在虚拟平台上，并且会去主动适应。

    类虚拟化是通过修改虚拟机操作系统内核，替换掉不能虚拟化的指令实现的。    

### 3.6.2 按VMM实现结构分类

    1.Hypervisor 模型

    在Hypervisor 模型中,VMM首先可以被看做是一个完备的操作系统，不过和传统操作系统不同的是，VMM 是为虚拟化而设计的，因此还具备虛拟化功能。在Hypervisor 模型中，由于VMM 同时具备物理资源的管理功能和虚拟化功能，因此，物理资源虚拟化的效率会更高一些。由于VMM完全拥有物理资源，因此，VMM 需要进行物理资源的管理，包括设备的驱动。这就要求在VMM中实现大量的驱动。

    2.宿主模型

    在宿主模型中，物理资源由宿主机操作系统管理，且VMM做为宿主机的内核模块来实现虚拟化。VMM通过调用宿主机操作系统的服务来获得资源，实现处理器、内存和I/O设备的虚拟化。VMM创建出虚拟机之后，通常将虚拟机作为宿主机操作系统的一个进程参与调度。

    3.混合模型

    VMM依然位于最底层，拥有所有的物理资源。 与Hvpervisor 模式不同的是，VMM会主动让出大部分I/O 设备的控制权，将它们交由一 个运行在特权虚拟机中的特权操作系统来控制。相应的，VMM虚拟化的职责也被分担。 处理器和内存的虚拟化依然由VMM来完成,而I/O 的虚拟化则由VMM和特权操作系统共同合作来完成。    

## 第四章 基于软件的完全虚拟化

## 4.2 cpu虚拟化

### 4.2.2  扫描与修补

    由于解释执行有很大的性能损失，加上虚拟机中模拟的CPU 和物理CPU 的体系结构 是相同的，这样大多数指令可以被映射到物理CPU上直接运行，因此，CPU 虚拟化过程中 可以采用更优化的模拟技术来弥补虚拟化漏洞。

    扫描与修补就让大多数指令到物理cpu上执行，而把操作系统代码中的敏感指令替换为跳转指令或会陷入到 VMM 中去的指令，使其—旦运行到敏感指令处控制流就会进入VMM中，由VMM代为模拟执行。

    扫描与修补的流程：1）VMM会在虚拟机开始执行每段代码之前对其进行扫描，解析每一条指令,查找到特权指令和敏感指令    2）补丁代码会在VMM中动态生成，通常每一个需要修补的指令会对应一块补丁代码。 3）敏感指令被替换成一个外跳转，从虚拟机跳转到VMM的空间里，在VMM中执行动态生成的补丁代码。 4）当补丁代码执行完后，执行流再跳转回虚拟机中的下一条代码继续执行。 （将敏感指令和特权指令扫描出来，用对应的补丁代码替换）

### 4.2.3 二进制代码翻译

    二进制代码翻译技术（BT技术）在VMM中开辟一块代码缓存，将代码翻译好放在其中。这样，客户机操作系统代码并不会直接被物理CPU执行，所有要被执行的代码都会在代码缓存中。

    基本块：表示只有一个入口和一个出口的代码块，不会在代码中间跳出去，也不会有外界跳转到代码块中间的某个地方。

    BT 技术的动态翻译也是以基本块为单位的，我们称之为动态基本块。BT 技术将源代码以基本块为粒度翻译代码，模拟器动态地、按需要地读入二进制代码进行翻译，将翻译好的目标代码存放在模拟器开辟的内存空间中，这块空间被称为代码缓存 (translation cache) 。源 代 码 中 的 指 令 与 翻 译 后 的 代 码 用 某 种 映 射 关 系 联 系 起 来 , 例 如 ，最 常 用 的 是 哈 希 表 ， 即由源代码的PC 值通过哈希丽数计算查表得到其在代码缓存区中的位置。源代码中的指令与翻译后的代码用某种映射关系联系起来，例如，最常用的是哈希表，即由源代码的PC值通过哈希函数计算查表得到其在代码缓存区中的位置。

    翻译分为两种：简单翻译和等值翻译，简单翻译比较直接，但是指令数量会增加，等值翻译会高效，但是动态分析比较困难。

    等值翻译在以下几种情况不适用：1）pc相对寻址的指令：模拟器的翻译模块需要在目标代码中插入一些补偿代码来确保寻址的正确。这类翻译会导致目标代码少量增大，因而引起一些性能损失。  2）直接控制转换：原代码中的控制转换，例如函数调用和跳转指令，其目标地址需要被替换成存于代码缓存的目标代码地址。其中，直接调用和直接跳转可以被直接替换为代码缓存中的目标地址，因为它们是固定的，其引起的性能损失是可忽略的。  3）间接控制转换：间接调用、返回和间接跳转的目标地址是动态运行时得到的。由 于目标地址不固定，代码翻译时就无法鄉定跳转目标。跳转目标通常在动态时计算出来，例 如通过查询哈希表。  4）特权指令：分为简单特权指令和复杂特权指令，对于简单特权指令只需要设置模拟器中寄存器的指令就可以，对于复杂特权指令，需要从客户机跳转到VMM中进行深度模拟。

    QEMU从宿主机得到中断和异常的信号，像缺页异常就是由宿主机先收到并处理的，宿主机会发送信号将异常通知给QEMU，QEMU进程的执行被打断，转而执行信号处理函数。信号处理函数会用类似方法将中断或异常向上传播给客户机操作系统。

## 4.3 内存虚拟化

    内存虚拟化的目的有两个：1） 提供给虛拟机 一个从零地址开始的连续物理内存空间。 2）在各虚拟机之间有效隔离、调度以及共享内存资源。

### 4.3.1 概述

    为了让容户机操作系统使用一个隔离的、从零开始且具有连续性的内存空间，VMM 引入了一层新的地址空间，即客户机物理地址空间。

    为了实现从客户机物理地址GPA 到宿主机物理地址HPA的地址翻译，VMM 为每个虚拟机动态地维护了一张从客户机物理地址到宿主机物理地址映射关系的表。有了这张表之后，VMM截获任何试图修改客户机页表或刷新TLB的指令，根据这张表,将修改从客户机虚拟地址到客户机物理地址映射的操作，变成修改客户机虚拟地址到相应的宿主机物理地址映射的操作。

### 4.3.2 影子页表

    如果每次都要经过GVA → GPA 和 GPA → HPA，那么在涉及内存访问频繁的程序时，就会多次在客户机和VMM之间切换，性能损失很大，现在维护了一张表直接记录了GVA → HPA，交给虚拟mmu处理，在每次客户机要访问内存时，就不用切换到VMM中。这张表就叫影子页表。

    客户机中的虚拟mmu维护的是GVA → GPA，在原先VMM只负责维护GPA → HPA，但是由于性能原因，VMM又维护了GVA → HPA影子页表，并将影子页表加载到物理mmu中。

    当客户机操作系统修改从客户机虚拟地址到客户机物理地址的内存映射关系，即企图修改它所维护的客户机页表时，为了保证一致性，VMM必须对影子页表也做相应的维护。为此，VMM必须截获这样的内存访问操作，修改在影子页表中同一客户机虚拟地址到宿主机物理地址的映射关系，使之仍然符合从客户机物理地址到宿主机物理地址的映射关系，这保证了客户机的正确执行，也带来额外的性能开销。

    对于客户机操作系统修改客户机页表的操作。由于客户机对自身维护的页表是有读写权限的，所以VMM无法捕获到客户机修改页表的操作。因此在影子页表中，对于页表页访问权限是只读的。任何写页表页的操作都会触发缺页异常，由VMM截获处理。在处理函数中，VMM除了代客户机操作系统更新页表项之外，还会将更新的GPA翻译成HPA，同时更新影子页表。

# 第五章 硬件辅助虚拟化

## 5.2 CPU虚拟化的硬件支持

    VT-x引入了两种操作模式，统称为VMX操作模式

    1）根操作模式：VMM运行所处模式

    2）非根操作模式：客户机运行所处模式

![](/Users/maliang/Library/Application%20Support/marktext/images/2025-06-16-17-38-29-image.png)

    这两种操作模式与IA32特权级0~ 特权级3是正交的，即每种操作模式下都有相应的 特权级0~特权级了特权级。故在VT-x 使用的情况下，描述程序运行在某个特权级，例如特权级0，还必须指出当前是处于根模式还是非根模式。

    VT-x中,非根模式下敏感指令引起的"陷人"被称为VM-Exit。VM-Exit发生时,CPU自动从非根模式切换成为根模式。相应地，VT-x也定义了VM-Entry,该操作由VMM发起,通常是调度某个客户机运行，此时CPU从根模式切换成为非根模式。

    为了更好支持cpu虚拟化，VT-x引入了VMCS，VMCS保存虚拟cpu需要的相关状态。例如cpu在根模式和非根模式下的特权寄存器的值。VMCS 主要供CPU使用，CPU在发生VM-Exit和VM-Entry 时都会自动查询和更新VMCS。

### 5.2.2 VMCS

    VMCS是保存在内存中的数据结构，包含了虚拟CPU的相关寄存器的内容和虚拟CPU相关的控制信息，每个VMCS对应一个虚拟CPU。与之前的虚拟器不同的是，虚拟寄存器是完全由软件来维护的，而VMCS主要是由cpu操作的。

    VMCS在使用时需要与物理CPU鄉定。在任意给定时刻，VMCS 与物理CPU 是一对 一的 绑定关系，即一个物理CPU只能绑定一个VMCS,一个VMCS 也只能与 一个物理 CPU绑定。VMCS在不同的时刻可以绑定到不同的物理CPU, 例如在某个VMCS先和物 理CPU1绑定，并在某个时刻解除绑定关系，并重新绑定到物理CPU2。这种绑定关系的变化称为VMCS的“迁移(Migration) ”。

    VT-x提供了两条指令用于VMCS的绑定与接触绑定：

    VMPTRLD<VMCS地址>:將指定的VMCS与执行该指令的物理CPU绑定

    VMCLEAR:将执行该指令的物理CPU与它的VMCS解除绑定。该指令会将物理CPU缓存中的VMCS结构同步到内存中去，从而保证VMCS和新的物理CPU绑定定时，内存中的值是最新的。

    VMCS的迁移过程如下：

    1）在cpu1上执行VMCLEAR，解除绑定

    2）在cpu2上执行VMPTRLD，进行新的绑定

    VT-x定义了VMCS的具体格式和内容。规定它是一个最大不超过4KB的内存块，并要求是4KB对齐。描述了VMCS的格式，各域描述如下：

    1）偏移0处是VMCS的版本标识

    2）偏移4处是VMX中止标识，VM-Exit执行不成功时产生VMX中止，CPU会在此处存入VMX中止的原因，以方便调试

    3）偏移8处是VMCS数据域，该域的格式是CPU相关的，不同型号的CPU可能使用不同的格式，具体使用哪种格式由VMCS 版本标识确定。

    VMCS主要信息存放在VMCS数据域：1）VMREAD<索引>:读VMCS中“索引”指定的域

2）VMWRITE<索引><数据>:写VMCS中“索引”指定的域

    VMCS数据域包含6大类信息：1）客户机状态域:保存客户机运行时，即非根模式时的CPU状态。  2）宿主机状态城:保存VMM运行时，即根模式时的CPU 状态。  3）VM-Entry控制域:控制VM-Entry的过程。 4）VM-Execution 控制域:控制处理器在VMX 非根模式下的行为。 5）VM-Exit控制域:控制VM-Exit的过程。  6）VM-Exit 信息域:提供VM-Exit 原因和其他的信息。VM-Exit信息域是只读的。

    1.客户机状态域：客户机状态域首先保存了一些寄存器的值，这些寄存器是必须由cpu进行更改的，如段寄存器，cr3，idtr，gdtr等。CPU通过这些寄存器的切换来实现客户机地址空间和VMM地址空间的切换。除了寄存器以外，还包含了一些内容用于精确模拟cpu，如中断状态域。

![](/Users/maliang/Library/Application%20Support/marktext/images/2025-06-17-10-37-00-image.png)

    2.宿主机状态域：宿主机状态城只在 VM-Exit 时被恢复，在VM-Entry时不用保存。这是因为宿主机状态域的内容通常几乎不需要改变。当需要改变时， VMM 可以直接对该域进行修改, 别忘了，VMCS 是保存在内存中的。宿主机状态域只包含寄存器值。![](/Users/maliang/Library/Application%20Support/marktext/images/2025-06-17-10-37-21-image.png)

### 5.2.3 VMX操作模式

    在默认情况下，VMX操作模式是关闭的：1）VMXON:打开VMX操作模式。  2）VMXOFF:关闭VMX操作模式。

    操作过程：1）VMM执行VMXON指令进入到VMX操作模式，CPU处于VMX根操作模式，VMM软件开始执行。2）VMM执行VMLAUNCH或VMRESUME指令产生VM-Entry，客户机软件开始执行，此时CPU进入非根模式。 3）当客户机执行特权指令，或者当客户机运行时发生了中断或异常，VM-Exit被触发而陷入到VMM，CPU切换到根模式。VMM根据VM-Exit的原因做相应处理，然后转到步骤(2)继续运行客户机。 4）如果VMM决定退出,则执行VMXOFF关闭VMX操作模式。

### 5.2.4 VM-Entry

    1.VM-Entry：VM-Entry是指cpu从根模式到非根模式，这个操作通常由VMM发起。在发起之前，VMM会设置好VMCS相关域的内容，例如客户机状态域、宿主机状态域。VT-x为entry提供了两条指令：1）VMLAUNCH:用于刚执行过VMCLEAER的VMCS的第一次VM-Entry。 2）VMRESUME:用于执行过VMLAUNCH的VMCS的后续VM-Entry。

    VM-Entry Interruption-Information字段：在VM-Entry时，在执行客户机命令前，CPU先会检查这个字段的最高位，如果是1，则根据bit 10:8指定的中断类型和bit 7:0指定的向量号在当前的客户机中引发一个异常、中断或NMI。

![](/Users/maliang/Library/Application%20Support/marktext/images/2025-06-17-11-23-19-image.png)

    2.VM-Entry的过程

    当CPU执行VMLAUNCH/VMRESUME进行VM-Entry时，处理器要进行下面的步骤:

1)执行基本的检查来确保VM -Entry 能开始。 2)对VMCS中的宿主机状态域的有效性进行检查，以确保下一次VM-Exit发生时可以正确地从客户机环境切换到VMM环境。 3)检查 VMCS 中客户机状态域的有效性;根据VMCS 中客户机状态城区域来装载 处理器的状态。4)根据VMCS中VM-Entry MSR-load区域装载MSR寄存器。5)根据VMCS中VM-Entry事件注入控制的配置，可能需要注入一个事件到客户机中。    如果1-4步中有一步错误，CPU就会报告VM-Entry失败。

### 5.2.5 VM-Exit

    VM-Exit是指CPU从非根模式切换到根模式，从客户机切换到VMM的操作。例如在非根模式下执行敏感指令、发送中断等，都会发生VM-Exit

    1.非根模式下的敏感指令

    敏感指令如果运行在VMX非根操作模式，其行为可能会发生变化。具体来说有如下三种可能：1）行为不变化，但不引起VM-Exit：这意味着虽然是敏感指令，但它不需要被VMM截获和模拟，例如SYSENTER指令。  2）行为变化，产生 VM-Exit ，这就是典型需要截获并模拟的敏感指令。  3）行为变化，产生VM-Exit可控:这类敏感指令是否产生VM-Exit,可以通过VM-Execution域控制(见下节)。出于优化的目的，VMM可以让某些敏感指令不产生VM-Exit，以减小模式切换带来的上下文开销。

    2.VM-Execution控制域

    VM-Execution 控制域主要控制三个方面：1）控制某条敏感指令是否产生VM-Exit，如果产生VM-Exit，则由VMM模拟该指令。  2）在某些敏感指令不产生VM-Exit时，控制该指令的行为。  3）异常和中断是否产生 VM- Exit。

    一些VM-Execution控制域：

![](/Users/maliang/Library/Application%20Support/marktext/images/2025-06-17-12-01-31-image.png)

    3.VM-Exit控制域：

    VM-Exit 控制域规定了VM-Exit 发生时CPU的行为：

![](/Users/maliang/Library/Application%20Support/marktext/images/2025-06-17-12-03-02-image.png)

    4.VM-Exit信息域：

    VMM除了要通过VM-Exit控制域来控制VM-Exit的行为外，还需要知道VM-Exit的相关信息(如退出原因)。VM-Exit信息域满足了这个要求，其提供的信息可以分为如下4类：1）基本的VM-Exit信息，包含以下内容：a）Exit Reason

![](/Users/maliang/Desktop/工作/笔记/2025-06-17-12-05-57-image.png)

b）Exitqualification:提供VM-Exit 的进一步原因。这个字段的值根据VM-Exit基本 退出原因的不同而不同。例如，对于因为访问CR奇存器导致的VM-Exit,Exit qualitication 提 供的信息包括:是哪个CR 奇存器、访问类型是读还是写、访问的内容等

    2)事件触发导致的VM-Exit 的信息。事件是指外部中断、异常、NMI,对于此类VM-Exit，VMM可以通过VM-Exit interruption information字段和VM-Exit interruption error code字段获取额外信息

    3)事件注人导致的VM-Exit 的信息。一 个事件在注人客户机时，可能由于某种原因 暂时不能成功，而触发VM-Exit。此时，VMM可以从IDT-vectoring information 宇段和 IDT-vectoringerror code中获取此类VM-Exit的额外信息

    4)执行敏感指令导致的VM-Exit 的信息。Guest linear address 字段给出了导致VM-Exit 指令的客户机线性地址，VM-Exit instruction length 字 段给出了该指令的长度,VM-Exit instruction information 字段给出了当该指令为VMX指令时的额外信息。

    5.VM-Exit具体过程

    1）CPU首先将此次VM-Exit的原因信息记录到VMCS相应的信息域中，VM-Entry interruption-information字段的有效位(bit31)被清零。

    2）CPU状态被保存到VMCS 客户机状态域。根据设置，CPU也可能将客户机的 MSR 保存到VM-Exit MSR- store 区城。

    3）根据VMCS 中宿主机状态域和VM- Exit 控制域中的设置，将宿主机状态加载到 CPU相应奇存器。

    4）CPU 由非根模式切换到了根模式，从宿主机状态域中CS: RIP 指定的VM-Exit 入口函数开始执行。

    5）在VMM处理完VM-Exit后，会通过VMLAUNCH/VMRESUME指令发起VM-Entry，进而重新运行客户机。

## 5.3 CPU虚拟化的实现

    硬件虚拟化使用VCPU描述符来描述虚拟CPU，VCPU描述符类似操作系统进程描述符，本质是一个结构体：

    1）VCPU表示信息

    2）虚拟寄存器信息

    3）VCPU状态信息：标识该VCPU当前运行状态例如睡眠、运行等，供调度器使用

    4）额外寄存器信息

    5）其他信息    

    VT-x情况下VCPU可以划分为两部分，一部分是由VMCS为主由硬件来维护的的部分，主要是虚拟寄存器。另一部分除了VMCS以外，由VMM维护的部分

![](/Users/maliang/Desktop/工作/系统虚拟化/img/2025-06-17-16-16-31-image.png)

### 5.3.2 VCPU的创建

    创建VCPU本质就是创建VCPU描述符，简单来说就是为VCPU分配对应大小的内存。VCPU描述符包含的内容很多，通常会被组织成多级结构。例如第一级结构体可以是各个平台通用的内容，中间包含一个指针指向第二级结构体，包含平台相关的内容。才VCPU描述符创建之后，需要进一步初始化。

### 5.3.3 VCPU的运行

    CPU上下文切换过程：

    1）VMM 保存自己的 上下文，主要是保存 VMCS 不保存的寄存器，即宿主机状态域以 外的部分

    2）VMM将保存在VCPU中的由软件切换的上下文加载到物理CPU 中

    3）VMM执行VMRESUME/VMLAUNCH指令触发VM-Entry时，CPU会自动将VCPU上下文中VMCS部分加载到物理CPU，同时切换至非根模式。

![](/Users/maliang/Desktop/工作/系统虚拟化/img/2025-06-17-16-28-42-image.png)

    2.VCPU的硬件优化

    1）无条件优化：以往在软件虚拟化下必须陷入到VMM的敏感指令，通过优化可以在客户机中直接执行

    2）条件优化：通过VMCS的VM-Execution控制域，可以配置某些敏感指令是否产生VM-Exit而陷入VMM中，例如对CR0、TSC的访问。

### 5.3.4 VCPU的退出

    1）发生VM-Exit，CPU自动进行一部分上下文的切换

    2）当CPU切换到根模式开始执行VM-Exit的处理函数后，进行另一部分的上下文切换

    根据VM-Exit 信息域获得发生VM-Exit 的原因，并分发到对应的处理模块处理。例 如，原因是执行了特权指令，则调用相应指令的模拟函数进行模拟。

    VCPU退出的原因：1）访问了特权资源：对于特权资源的：客户机认为自己掌握了所有资源的读写权限，但是实际上特权资源是由VMM来管理的，VMM通过引入“虚拟特权资源”和“影子特权资源”解决矛盾。虚拟特权资源是客户的看到特权资源，客户机可以随便读写：影子特权资源是客户机真正用到的特权资源，由VMM在虚拟特权资源上处理后得到的。在客户机读特权寄存器时，VMM将虚拟特权资源返回。在客户机写特权寄存器时，VMM先写到虚拟特权资源中，然后根据虚拟化策略来更新影子特权寄存器，最后将影子寄存器的值应用到VCPU中。      2）客户机执行的指令发生了异常如缺页异常。    3）发生中断

## 5.5 内存虚拟化

    VT-x提供了EPT技术，在硬件上支持两次地址转换

### 5.5.2 EPT

    设立EPT页表，记录了GVA->HPA，先客户机的CR3，查TLB，如果没命中就在EPT中从L4查L3，如果L4页表中GVA对于的表项为缺页，那么cpu产出page falut，交给客户机kernel处理，不产生VM-Exit

![](/Users/maliang/Desktop/工作/系统虚拟化/img/2025-06-17-18-09-45-image.png)

    2.EPT的硬件支持：

    VM-Execution 控制域提供了enable ept的字段，在VM-Entry时该字段被置，则使用EPT

    

    
