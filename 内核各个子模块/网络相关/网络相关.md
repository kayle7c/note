# socket

## 数据结构

### socket数据结构

socket数据结构是对用户层的封装，socket的结构定义如下

```c
struct socket {
	socket_state		state;
	short			type;
	unsigned long		flags;
	struct file		*file;
	struct sock		*sk;
	const struct proto_ops	*ops;
	struct socket_wq	wq;
};
```

● state表示套接字的连接状态，可使用下列值

```c
typedef enum {
  SS_FREE = 0,        //未分配
  SS_UNCONNECTED,     //未连接到任何套接字
  SS_CONNECTING,      //处于连接过程中
  SS_CONNECTED,       //已经连接到套接字
  SS_DISCONNECTING    //处于断开连接过程中
} socket_state;
```

● type指定套接字的语义类型

● file指向内核的 struct file，将套接字与文件系统接口绑定。用户通过fd访问套接字，内核通过struct file的private_data字段找到对应的struct socket。

● flags存储套接字的配置选项

● sk指向底层协议栈的struct sock

● ops指向协议族的操作函数表，定义套接字的具体行为

```c
struct proto_ops {
	int		family;
	struct module	*owner;
	int		(*release)   (struct socket *sock);
	int		(*bind)	     (struct socket *sock,
				      struct sockaddr *myaddr,
				      int sockaddr_len);
	int		(*connect)   (struct socket *sock,
				      struct sockaddr *vaddr,
				      int sockaddr_len, int flags);
	int		(*socketpair)(struct socket *sock1,
				      struct socket *sock2);
	int		(*accept)    (struct socket *sock,
				      struct socket *newsock, int flags, bool kern);
	int		(*getname)   (struct socket *sock,
				      struct sockaddr *addr,
				      int peer);
	__poll_t	(*poll)	     (struct file *file, struct socket *sock,
				      struct poll_table_struct *wait);
	int		(*ioctl)     (struct socket *sock, unsigned int cmd,
				      unsigned long arg);
    ...
}

```

● wq管理套接字的等待队列和异步通知机制

### sock数据结构

相比于socket，sock是对网络系统的内核部分的封装，sock数据结构如下：

```c
struct sock {
	
    struct sock_common	__sk_common;
    struct sk_buff_head	sk_receive_queue;
    struct sk_buff_head	sk_write_queue;
    socket_lock_t		sk_lock;
    void			(*sk_data_ready)(struct sock *sk);
    ...
}

```

● sock结构体中包含了大量成员，有很多是很少用的，最重要的一些成员被放在了sock_common中

```c
struct sock_common {
    unsigned short		skc_family;
    volatile unsigned char	skc_state;
    struct proto		*skc_prot;

}
```

## tcp下socket收包流程

在用户态中使用recv系统调用去接受socket的数据,内核态的对应处理函数为__sys_recvfrom，由于用户态只知道socket对应的文件描述符fd，但是在内核中去操作时需要操作socket结构体，所以sockfd_lookup_light就负责将fd转换为对应的socket结构体

```c
int __sys_recvfrom(int fd, void __user *ubuf, size_t size, unsigned int flags,
		   struct sockaddr __user *addr, int __user *addr_len)
{
	struct socket *sock;
	struct iovec iov;
	struct msghdr msg;
	struct sockaddr_storage address;
	int err, err2;
	int fput_needed;

    //将用户空间的数据映射到内核空间
	err = import_single_range(READ, ubuf, size, &iov, &msg.msg_iter);
	if (unlikely(err))
		return err;
    //根据文件描述符fd，查找对应的socket对象
	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (!sock)
		goto out;

	msg.msg_control = NULL;
	msg.msg_controllen = 0;
	/* Save some cycles and don't copy the address if not needed */
	msg.msg_name = addr ? (struct sockaddr *)&address : NULL;
	/* We assume all kernel code knows the size of sockaddr_storage */
	msg.msg_namelen = 0;
	msg.msg_iocb = NULL;
	msg.msg_flags = 0;
	if (sock->file->f_flags & O_NONBLOCK)
		flags |= MSG_DONTWAIT;
    //从socket接收信息
	err = sock_recvmsg(sock, &msg, flags);

	if (err >= 0 && addr != NULL) {
		err2 = move_addr_to_user(&address,
					 msg.msg_namelen, addr, addr_len);
		if (err2 < 0)
			err = err2;
	}

	if (recvfrom_info_flag && hook_info_flag && err >= 0) {
		__this_cpu_inc(recvfrom_count);
		if (get_info_func[RECVFROM_INFO] != NULL)
			get_info_func[RECVFROM_INFO](sock, fd, &address, err);
		__this_cpu_dec(recvfrom_count);
	}

	fput_light(sock->file, fput_needed);
out:
	return err;
}

```

sock_recvmsg中做了安全检查后就交给sock_recvmsg_nosec,这个函数使用INDIRECT_CALL_INET宏进行间接调用,根据sock结构中的操作指针sock->ops->recvmsg动态选择调用inet_recvmsg或inet6_recvmsg

```c
static inline int sock_recvmsg_nosec(struct socket *sock, struct msghdr *msg,
				     int flags)
{
	return INDIRECT_CALL_INET(sock->ops->recvmsg, inet6_recvmsg,
				  inet_recvmsg, sock, msg, msg_data_left(msg),
				  flags);
}

int sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags)
{
	int err = security_socket_recvmsg(sock, msg, msg_data_left(msg), flags);

	return err ?: sock_recvmsg_nosec(sock, msg, flags);
}

```

在ipv4下，sock->ops->recvmsg绑定的是inet_recvmsg，在sk->sk_prot->recvmsg中去指定是tcp协议还是udp

```c
int inet_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,
		 int flags)
{
	struct sock *sk = sock->sk;
	int addr_len = 0;
	int err;

	if (likely(!(flags & MSG_ERRQUEUE)))
		sock_rps_record_flow(sk);

	err = INDIRECT_CALL_2(sk->sk_prot->recvmsg, tcp_recvmsg, udp_recvmsg,
			      sk, msg, size, flags & MSG_DONTWAIT,
			      flags & ~MSG_DONTWAIT, &addr_len);
	if (err >= 0)
		msg->msg_namelen = addr_len;
	return err;
}

```

以tcp为例，在tcp_recvmsg中处理，整体代码过长，只展示关键部分

A：判断是否有最新消息:sk_can_busy_loop判断socket是否支持忙等待，如果消息队列为空skb_queue_empty_lockless，并且tcp连接状态为TCP_ESTABLISHED，就会执行忙等待，通过主动轮询来减少在数据准备好之前的睡眠时间。

```c
if (sk_can_busy_loop(sk) && skb_queue_empty_lockless(&sk->sk_receive_queue) &&
	    (sk->sk_state == TCP_ESTABLISHED))
		sk_busy_loop(sk, nonblock);

```

B:匹配skb逻辑：通过skb_queue_walk去遍历skb，找到包含所需要的seq的skb，再交给found_ok_skb处理

```c
        //遍历接收队列中的每个skb
		skb_queue_walk(&sk->sk_receive_queue, skb) {
			last = skb;
          //保证seq在TCP_SKB_CB(skb)->seq之后
          //seq是当前要读取的起始序列号，TCP_SKB_CB(skb)->seq是该数据包的tcp序列号
          if (WARN(before(*seq, TCP_SKB_CB(skb)->seq),
				 "TCP recvmsg seq # bug: copied %X, seq %X, rcvnxt %X, fl %X\n",
				 *seq, TCP_SKB_CB(skb)->seq, tp->rcv_nxt,
				 flags))
				break;
          //计算数据偏移量，现在有两种情况：
          //1）seq=1100，当前 skb 的 seq=1000，len=200，offset= 1100 - 1000 = 100
          //此时offset>len，说明该skb包含了我们需要的数据
          //2）seq=1500，当前 skb 的 seq=1000，len=200，offset= 1500 - 1000 = 500
          //此时offset<len,说明该skb不是我们要的数据
			offset = *seq - TCP_SKB_CB(skb)->seq;
			if (unlikely(TCP_SKB_CB(skb)->tcp_flags & TCPHDR_SYN)) {
				pr_err_once("%s: found a SYN, please report !\n", __func__);
				offset--;
			}
          //结合上面的逻辑，说明找到了需要的skb
			if (offset < skb->len)
				goto found_ok_skb;
			if (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)
				goto found_fin_ok;
			WARN(!(flags & MSG_PEEK),
			     "TCP recvmsg seq # bug 2: copied %X, seq %X, rcvnxt %X, fl %X\n",
			     *seq, TCP_SKB_CB(skb)->seq, tp->rcv_nxt, flags);
		}


```

C:数据复制到用户空间：当确定了哪个skb包含所需要的数据和从skb哪个位置开始复制时，只需要计算要复制的数据长度，之后交给skb_copy_datagram_msg去复制到用户空间。

```c
found_ok_skb:
		//计算当前skb中可读取的最大数据量
		used = skb->len - offset;
       //若用户请求的长度更小，则取用户请求的长度
		if (len < used)
			used = len;

        ...
        
		if (!(flags & MSG_TRUNC)) {
          //从 skb 中指定的 offset 处开始，将 used 字节的数据复制到用户空间的 msg 中
			err = skb_copy_datagram_msg(skb, offset, msg, used);
			if (err) {
				/* Exception. Bailout! */
				if (!copied)
					copied = -EFAULT;
				break;
			}
		}
       //更新seq
       WRITE_ONCE(*seq, *seq + used);

```

总结整个收包流程：

```
1.用户程序调用recv()系统调用。
2.系统调用转换到内核空间，如果是ipv4，tcp协议，就会在tcp_recvmsg中处理数据，找到seq对应的skb，确定要读取的skb，skb的开始偏移，要读取的长度。
3.skb_copy_datagram_msg()负责从skb到msg的数据复制，从skb的指定offset开始，复制used字节的数据到 msg->msg_iov指向的用户空间缓冲区。
4.更新seq等数据状态。
```
